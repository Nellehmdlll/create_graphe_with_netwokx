# -*- coding: utf-8 -*-
"""Untitled9.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1f3odjQmbc52STryE46BammAfFRliACkk
"""

import matplotlib.pyplot as plt
import networkx as nx

# Définition des tâches (durée, prédécesseurs)
tasks = [
    (2, []),        # 0 : Permis
    (7, []),        # 1 : Maçonnerie
    (3, [0, 1]),    # 2 : Charpente
    (1, [2]),       # 3 : Toiture
    (8, [0, 1]),    # 4 : Plomberie
    (2, [3, 4]),    # 5 : Façade
    (1, [3, 4]),    # 6 : Fenêtre
    (1, [3, 4]),    # 7 : Jardin
    (3, [6]),       # 8 : Plafonds
    (2, [8]),       # 9 : Peintures
    (1, [5, 9])     # 10 : Emménagement
]

import matplotlib.pyplot as plt
import networkx as nx

# Définir les tâches (durée, prédécesseurs)
tasks = [
    (2, []), (7, []), (3, [0, 1]), (1, [2]),
    (8, [0, 1]), (2, [3, 4]), (1, [3, 4]),
    (1, [3, 4]), (3, [6]), (2, [8]), (1, [5, 9])
]

# Création du graphe orienté
G = nx.DiGraph()

# Ajouter les nœuds et arcs
for i, (duration, preds) in enumerate(tasks):
    G.add_node(i, label=f"T{i}")
    for p in preds:
        G.add_edge(p, i, weight=tasks[p][0])

# Ajouter les nœuds Début et Fin
G.add_node(-1, label="Début")
G.add_edge(-1, 0)
G.add_edge(-1, 1)
G.add_node(11, label="Fin")
G.add_edge(7, 11)
G.add_edge(10, 11)

# Position des nœuds (horizontal)
pos = {
    -1: (0, 5), 0: (1, 6), 1: (1, 4), 2: (2, 5),
    3: (3, 5), 4: (2, 3), 5: (4, 4), 6: (4, 2),
    7: (4, 0), 8: (5, 2), 9: (6, 2), 10: (7, 2), 11: (8, 2)
}

# Dessin du graphe avec flèches visibles
plt.figure(figsize=(16, 8))

# Utiliser nx.draw pour inclure automatiquement les flèches visibles
nx.draw(
    G, pos,
    with_labels=False,
    node_color="lightgreen",
    edge_color="black",
    node_size=2500,
    arrows=True,
    arrowsize=20,
    arrowstyle="-|>"
)

# Redessiner les nœuds Début et Fin dans une autre couleur
nx.draw_networkx_nodes(G, pos, nodelist=[-1, 11], node_color="skyblue", node_size=2500)

# Étiquettes des nœuds
nx.draw_networkx_labels(G, pos, labels=nx.get_node_attributes(G, 'label'), font_size=10)

# Étiquettes des durées
edge_labels = {(u, v): f"{tasks[u][0]}S" for u, v in G.edges() if u >= 0 and v <= 11}
nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=9)

plt.title("Graphe orienté du projet de M. Clément B.", fontsize=14)
plt.axis("off")
plt.tight_layout()
plt.show()

#6. Implémentation de la fonction
def project(L):
    n = len(L)
    durations = [L[i][0] for i in range(n)]
    predecessors = [L[i][1] for i in range(n)]

    # 1. Construire le graphe et le degré entrant
    from collections import defaultdict, deque

    graph = defaultdict(list)
    in_degree = [0] * n
    for i, preds in enumerate(predecessors):
        for p in preds:
            graph[p].append(i)
            in_degree[i] += 1

    # 2. Tri topologique
    queue = deque([i for i in range(n) if in_degree[i] == 0])
    topo_order = []
    while queue:
        node = queue.popleft()
        topo_order.append(node)
        for succ in graph[node]:
            in_degree[succ] -= 1
            if in_degree[succ] == 0:
                queue.append(succ)

    # 3. Date au plus tôt
    earliest = [0] * n
    for i in topo_order:
        for j in graph[i]:
            earliest[j] = max(earliest[j], earliest[i] + durations[i])

    project_duration = max(earliest[i] + durations[i] for i in range(n))
    print(earliest)

    # 4. Date au plus tard
    latest = [project_duration] * n
    for i in reversed(topo_order):
        if not graph[i]:  # tâche finale
            latest[i] = project_duration - durations[i]
        for j in graph[i]:
            latest[i] = min(latest[i], latest[j] - durations[i])
    print(latest)

    # 5. Résultat
    result = []
    for i in range(n):
        slack = latest[i] - earliest[i]
        result.append({
            "tâche": i,
            "DE (au plus tôt)": earliest[i],
            "slack (marge)": slack
        })

    return result, project_duration

#Résultat du projet
résultat, durée = project(tasks)

for r in résultat:
    print(f"Tâche {r['tâche']} : DE = {r['DE (au plus tôt)']}, Slack = {r['slack (marge)']}")
print(f"Durée minimale du projet : {durée} semaines")

##Tâches critiques et chemin critique (coloré en rouge)

# Tâches : (durée, prédécesseurs)
tasks = [
    (2, []), (7, []), (3, [0, 1]), (1, [2]),
    (8, [0, 1]), (2, [3, 4]), (1, [3, 4]),
    (1, [3, 4]), (3, [6]), (2, [8]), (1, [5, 9])
]

# Création du graphe orienté
G = nx.DiGraph()
for i, (duration, preds) in enumerate(tasks):
    G.add_node(i, label=f"T{i}")
    for p in preds:
        G.add_edge(p, i, weight=tasks[p][0])
G.add_node(-1, label="Début")
G.add_edge(-1, 0)
G.add_edge(-1, 1)
G.add_node(11, label="Fin")
G.add_edge(7, 11)
G.add_edge(10, 11)

# Position des nœuds
pos = {
    -1: (0, 5), 0: (1, 6), 1: (1, 4), 2: (2, 5),
    3: (3, 5), 4: (2, 3), 5: (4, 4), 6: (4, 2),
    7: (4, 0), 8: (5, 2), 9: (6, 2), 10: (7, 2), 11: (8, 2)
}

# Calcul des dates au plus tôt / plus tard
def project(L):
    n = len(L)
    durations = [L[i][0] for i in range(n)]
    predecessors = [L[i][1] for i in range(n)]
    graph = {i: [] for i in range(n)}
    in_degree = [0] * n
    for i, preds in enumerate(predecessors):
        for p in preds:
            graph[p].append(i)
            in_degree[i] += 1
    queue = [i for i in range(n) if in_degree[i] == 0]
    topo_order = []
    while queue:
        node = queue.pop(0)
        topo_order.append(node)
        for succ in graph[node]:
            in_degree[succ] -= 1
            if in_degree[succ] == 0:
                queue.append(succ)
    earliest = [0] * n
    for i in topo_order:
        for j in graph[i]:
            earliest[j] = max(earliest[j], earliest[i] + durations[i])
    project_duration = max(earliest[i] + durations[i] for i in range(n))
    latest = [project_duration] * n
    for i in reversed(topo_order):
        if not graph[i]:
            latest[i] = project_duration - durations[i]
        for j in graph[i]:
            latest[i] = min(latest[i], latest[j] - durations[i])
    return earliest, latest, project_duration, topo_order

earliest, latest, project_duration, _ = project(tasks)
critical_tasks = [i for i in range(len(tasks)) if latest[i] == earliest[i]]

# Détection des arêtes critiques
critical_edges = [(u, v) for u, v in G.edges() if u in critical_tasks and v in critical_tasks]
non_critical_edges = [(u, v) for u, v in G.edges() if (u, v) not in critical_edges]

# Couleurs des arêtes
edge_colors = []
for u, v in G.edges():
    if (u, v) in critical_edges:
        edge_colors.append("red")
    else:
        edge_colors.append("gray")

# Couleurs des nœuds
node_colors = []
for node in G.nodes():
    if node in critical_tasks:
        node_colors.append("red")
    elif node in [-1, 11]:
        node_colors.append("skyblue")
    else:
        node_colors.append("lightgreen")

# Dessin du graphe avec flèches visibles
plt.figure(figsize=(16, 8))
nx.draw(
    G, pos,
    with_labels=False,
    arrows=True,
    arrowsize=20,
    arrowstyle="-|>",
    node_color=node_colors,
    edge_color=edge_colors,
    node_size=3000
)

# Étiquettes des nœuds
nx.draw_networkx_labels(G, pos, labels=nx.get_node_attributes(G, "label"), font_size=10)

# Étiquettes des durées (sur les arêtes, sauf Début et Fin)
edge_labels = {(u, v): f"{tasks[u][0]}S" for u, v in G.edges() if u >= 0 and v <= 11}
nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=9)

plt.title("Graphe orienté avec chemin critique (Coloré en rouge)", fontsize=14)
plt.axis("off")
plt.tight_layout()
plt.show()